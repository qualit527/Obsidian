/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ExportPaperPlugin
});
module.exports = __toCommonJS(main_exports);
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));
var import_obsidian4 = require("obsidian");

// src/export_longform/utils.ts
var import_obsidian = require("obsidian");
function notice_and_warn(message) {
  new import_obsidian.Notice(message);
  console.warn(message);
}
function escape_latex(input) {
  return input.replace(/\\/g, "\\textbackslash{}").replace(/%/g, "\\%").replace(/&/g, "\\&").replace(/#/g, "\\#").replace(/\$/g, "\\$").replace(/_/g, "\\_").replace(/\{/g, "\\{").replace(/\}/g, "\\}").replace(/\^/g, "\\^{}").replace(/~/g, "\\textasciitilde{}").replace(/</g, "\\textless{}").replace(/>/g, "\\textgreater{}").replace(/\|/g, "\\textbar{}").replace(/"/g, "''").replace(/'/g, "`");
}
function find_image_file(find_file, address) {
  const matchExcalidraw = /^.*\.excalidraw$/.exec(address);
  if (matchExcalidraw !== null) {
    address = matchExcalidraw[0] + ".png";
  }
  return find_file(address);
}
function strip_newlines(thestring) {
  const result = /^(?:(?:\s*?)\n)*(.*?)(?:\n(?:\s*?))?$/s.exec(thestring);
  if (result === null) {
    throw new Error("result is undefined");
  }
  return result[1];
}

// src/export_longform/interfaces.ts
var DEFAULT_SETTINGS = {
  mySetting: "default",
  template_path: "",
  base_output_folder: "/",
  preamble_file: "preamble.sty",
  bib_file: "bibliography.bib",
  prioritize_lists: false,
  // Whether to parse lists or equations first. Lists first allows lists containing display equations, but yields bugs because lines within an equation can easily start with '-'.
  warn_before_overwrite: true,
  default_citation_command: "cite",
  overwrite_preamble: false,
  display_env_titles: true,
  default_env_name_to_file_name: false,
  last_external_folder: "",
  overwrite_figures: false,
  overwrite_header: false
};
function init_data(longform_file, read_tfile, find_file) {
  return {
    in_thm_env: false,
    depth: 0,
    env_hash_list: [],
    parsed_file_bundle: {},
    ambient_header_level: 0,
    headers_level_offset: 0,
    explicit_env_index: 1,
    longform_file,
    current_file: longform_file,
    read_tfile,
    find_file,
    header_stack: [],
    // file-local stack of headers.
    media_files: [],
    bib_keys: []
  };
}
function address_is_image_file(address) {
  if (/\.(?:jpeg|svg|pdf|png|jpg|gif|svg|pdf|tiff|excalidraw?)$/.exec(address)) {
    return true;
  }
  return false;
}
async function unroll_array(data, content_array, settings) {
  const new_children = [];
  for (const elt of content_array) {
    new_children.push(...await elt.unroll(data, settings));
  }
  return new_children;
}

// src/export_longform/headers.ts
var ProofHeader = class {
  constructor(title) {
    this.title = title;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    const header_string = "\n\\textbf{" + this.title + "}\n\n";
    buffer_offset += buffer.write(header_string, buffer_offset);
    return buffer_offset;
  }
};
var Header = class {
  constructor(level, title, children, label, data) {
    this.level = level;
    this.title = title;
    this.children = children;
    this.label = label;
    if (data !== void 0) {
      this.data = data;
    }
  }
  async unroll(data, settings) {
    if (data.in_thm_env) {
      const new_children2 = [];
      for (const elt of this.children) {
        new_children2.push(...await elt.unroll(data, settings));
      }
      return [
        new ProofHeader(await this.latex_title(settings)),
        ...new_children2
      ];
    }
    this.level += data.headers_level_offset;
    data.ambient_header_level = this.level;
    for (let i = 0; i < data.header_stack.length; i++) {
      if (data.header_stack[i].level >= this.level) {
        data.header_stack = data.header_stack.slice(0, i);
        break;
      }
    }
    data.header_stack.push(this);
    this.data = {
      in_thm_env: data.in_thm_env,
      depth: data.depth,
      env_hash_list: data.env_hash_list,
      parsed_file_bundle: data.parsed_file_bundle,
      ambient_header_level: data.ambient_header_level,
      headers_level_offset: data.headers_level_offset,
      explicit_env_index: data.explicit_env_index,
      read_tfile: data.read_tfile,
      find_file: data.find_file,
      longform_file: data.longform_file,
      current_file: data.current_file,
      header_stack: [...data.header_stack],
      media_files: data.media_files,
      bib_keys: data.bib_keys
    };
    const new_title = [];
    for (const elt of this.title) {
      new_title.push(...await elt.unroll(data, settings));
    }
    this.title = new_title;
    const new_children = [];
    for (const elt of this.children) {
      new_children.push(...await elt.unroll(data, settings));
    }
    this.children = new_children;
    return [this];
  }
  async latex_title(settings) {
    const buffer = Buffer.alloc(1e3);
    let buffer_offset = 0;
    for (const e of this.title) {
      buffer_offset = await e.latex(buffer, buffer_offset, settings);
    }
    return buffer.toString("utf8", 0, buffer_offset);
  }
  async latex(buffer, buffer_offset, settings) {
    const header_title = await this.latex_title(settings);
    let header_string = "";
    if (this.level === 1) {
      header_string = "\\section{" + header_title + "}\n";
    } else if (this.level === 2) {
      header_string = "\\subsection{" + header_title + "}\n";
    } else if (this.level === 3) {
      header_string = "\\subsubsection{" + header_title + "}\n";
    } else if (this.level >= 4) {
      header_string = "\n\\textbf{" + header_title + "}\n\n";
    }
    buffer_offset += buffer.write(header_string, buffer_offset);
    const promises = this.data.header_stack.map(
      async (e) => await e.latex_title(settings)
    );
    buffer_offset += buffer.write(
      "\\label{" + await label_from_location(
        this.data,
        this.data.current_file.basename,
        //File the header came from
        this.data.current_file,
        settings,
        await Promise.all(promises)
      ) + "}\n",
      buffer_offset
    );
    for (const e of this.children) {
      buffer_offset = await e.latex(buffer, buffer_offset, settings);
    }
    return buffer_offset;
  }
};
async function find_header(header, current_content, settings) {
  let header_stack;
  if (typeof header === "string") {
    header_stack = header.split("#").reverse();
  } else {
    header_stack = [...header];
  }
  const next_checks = [];
  for (const node5 of current_content) {
    for (const elt of node5) {
      if (elt instanceof Header) {
        const current_check = header_stack[header_stack.length - 1];
        if (current_check === void 0) {
          throw new Error(
            "current_check is undefined, should not be possible."
          );
        }
        if (header_stack.length > 0 && (await elt.latex_title(settings)).toLowerCase().trim() == current_check.toLowerCase().trim()) {
          if (header_stack.length == 1) {
            return elt;
          }
          header_stack.pop();
        }
        next_checks.push(elt.children);
      }
    }
  }
  if (next_checks.length == 0) {
    return void 0;
  }
  return await find_header(header_stack, next_checks, settings);
}
async function get_header_address(header, current_content, settings, built_address) {
  let header_stack;
  if (typeof header === "string") {
    header_stack = header.split("#").reverse();
  } else {
    header_stack = [...header];
  }
  if (header_stack.length == 1 && header_stack[0] == "") {
    const statement_attempt = await get_header_address(["statement"], current_content, settings, built_address);
    return statement_attempt === void 0 ? "" : statement_attempt;
  }
  for (const elt of current_content) {
    if (elt instanceof Header) {
      const current_check = header_stack[header_stack.length - 1];
      console.assert(
        current_check !== void 0,
        "current_check is undefined"
      );
      const new_address = built_address === void 0 ? await elt.latex_title(settings) : built_address + "." + await elt.latex_title(settings);
      if (header_stack.length > 0 && (await elt.latex_title(settings)).toLowerCase().trim() == current_check.toLowerCase().trim()) {
        if (header_stack.length == 1) {
          return new_address;
        }
        header_stack.pop();
      }
      const attempt = await get_header_address(
        header_stack,
        elt.children,
        settings,
        new_address
      );
      if (attempt !== void 0) {
        return attempt;
      }
    }
  }
  return void 0;
}

// src/export_longform/labels.ts
function format_label(label) {
  return label.toLowerCase().trim().replace(/\\Cref{/g, "").replace(/}/g, "").replace(/ /g, "_").replace(/,/g, "").replace(/-/g, ":").replace(/\$/g, "").replace(/\\/g, "");
}
function explicit_label(longform_file, current_file, label) {
  if (current_file !== longform_file) {
    return explicit_label_with_address(label, current_file.basename);
  } else {
    return label;
  }
}
function explicit_label_with_address(label, address) {
  const match = /^([a-z]+)-(.*)$/.exec(label);
  if (match) {
    return format_label(match[1] + ":" + address + "." + match[2]);
  } else {
    return format_label(address + "." + label);
  }
}
async function label_from_location(data, address, file_of_origin, settings, header) {
  if (address_is_image_file(address)) {
    return format_label("fig:" + address);
  }
  if (address === "") {
    return "";
  }
  if (header === void 0) {
    header = "";
  }
  let resolved_head_label = await resolve_header_label(
    address,
    header,
    data.parsed_file_bundle,
    data.find_file,
    data.current_file,
    settings
  );
  if (resolved_head_label === void 0) {
    notice_and_warn(
      "could not resolve header at " + address + ": " + header + " keeping the header label as-is.\nIn note:\n" + file_of_origin.path
    );
    resolved_head_label = typeof header === "string" ? header : header.join(".");
  }
  if (address === "" || address === data.longform_file.basename) {
    return format_label("loc:" + resolved_head_label);
  }
  return resolved_head_label === "" ? format_label("loc:" + address) : format_label("loc:" + address + "." + resolved_head_label);
}
async function resolve_header_label(address, header, file_cache, find_file, file_of_origin, settings) {
  let file_content;
  const cached_content = file_cache[address];
  if (cached_content === void 0) {
    const file = find_file(address);
    if (file === void 0 || file_cache[file.basename] === void 0) {
      const header_string = typeof header === "string" ? header : header.join(".");
      return header_string;
    }
    file_content = file_cache[file.basename].body;
  } else {
    file_content = cached_content.body;
  }
  let new_label;
  if (typeof header === "string") {
    new_label = await get_header_address(header, file_content, settings);
  } else {
    new_label = await get_header_address(
      [...header].reverse(),
      file_content,
      settings
    );
  }
  if (new_label === void 0) {
    const header_string = typeof header === "string" ? header : header.join(".");
    notice_and_warn(
      "Could not resolve header name '" + header_string + "' in file with address '" + address + "', keeping the header label as-is\nIn note:\n" + file_of_origin.path
    );
    return header_string;
  }
  return new_label;
}

// src/export_longform/inline.ts
function split_inline(inline_arr, class_regexp, make_obj, settings) {
  const new_inline = [];
  for (const text of inline_arr) {
    if (text instanceof Text) {
      let current_match = null;
      let start_index = 0;
      while ((current_match = class_regexp.exec(text.content)) !== null) {
        if (current_match.index == null) {
          throw new Error("current_match.index is undefined");
        }
        const prev_chunk = text.content.slice(
          start_index,
          current_match.index
        );
        if (prev_chunk !== "") {
          new_inline.push(new Text(prev_chunk));
        }
        new_inline.push(make_obj(current_match, settings));
        start_index = current_match.index + current_match[0].length;
      }
      const last_string = text.content.slice(start_index);
      if (last_string !== "") {
        new_inline.push(new Text(last_string));
      }
    } else {
      new_inline.push(text);
    }
  }
  return new_inline;
}
var ExplicitRef = class {
  constructor(identifier, name) {
    this.label = identifier + "-" + name;
  }
  static get_regexp() {
    return /@(ref|loc|tbl|eq|lem|sec|lst|thm|def|ex|exr|prf|alg)\-([\w_:\-]+)/g;
  }
  static build_from_match(regexmatch, settings) {
    return new ExplicitRef(regexmatch[1], regexmatch[2]);
  }
  async unroll(data, settings) {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write(
      "\\Cref{" + format_label(this.label) + "}",
      buffer_offset
    );
  }
};
var Text = class {
  constructor(content) {
    this.content = content;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write(this.content, buffer_offset);
  }
};
var Emphasis = class {
  static get_regexp() {
    return /(?:\*(\S.*?)\*)|(?:_(\S.*?)_)/gs;
  }
  static build_from_match(regexmatch, settings) {
    if (regexmatch[1] !== void 0) {
      return new Emphasis(regexmatch[1]);
    } else if (regexmatch[2] !== void 0) {
      return new Emphasis(regexmatch[2]);
    } else {
      throw new Error("Unexpected regex match");
    }
  }
  constructor(content) {
    this.content = content;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("\\emph{" + this.content + "}", buffer_offset);
  }
};
var DoubleQuotes = class {
  static get_regexp() {
    return /(?:"(\S.*?)")/gs;
  }
  static build_from_match(regexmatch, settings) {
    return new DoubleQuotes(regexmatch[1]);
  }
  constructor(content) {
    this.content = content;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("``" + this.content + '"', buffer_offset);
  }
};
var SingleQuotes = class {
  static get_regexp() {
    return /(?:'(\S.*?)')/gs;
  }
  static build_from_match(regexmatch, settings) {
    return new SingleQuotes(regexmatch[1]);
  }
  constructor(content) {
    this.content = content;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("`" + this.content + "'", buffer_offset);
  }
};
var Strong = class {
  // similar to emphasis but with double asterisks
  static get_regexp() {
    return /(?:\*\*(\S.*?)\*\*)|(?:__(\S.*?)__)/gs;
  }
  static build_from_match(regexmatch, settings) {
    if (regexmatch[1] !== void 0) {
      return new Strong(regexmatch[1]);
    } else if (regexmatch[2] !== void 0) {
      return new Strong(regexmatch[2]);
    } else {
      throw new Error("Unexpected regex match");
    }
  }
  constructor(content) {
    this.content = content;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("\\textbf{" + this.content + "}", buffer_offset);
  }
};
var InlineMath = class {
  static get_regexp() {
    return /\$([^\$]+)\$(?:{(.*?)})?/g;
  }
  static build_from_match(regexmatch, settings) {
    return new InlineMath(regexmatch[1], regexmatch[2]);
  }
  constructor(content, label) {
    this.content = content;
    this.label = label;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("$" + this.content + "$", buffer_offset);
  }
};
var InlineCode = class {
  static get_regexp() {
    return /`(.*?)`/gs;
  }
  static build_from_match(match, settings) {
    return new InlineCode(match[1]);
  }
  constructor(content) {
    this.code = content;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("\\texttt{" + this.code.replace("_", "_") + "}", buffer_offset);
  }
};

// src/export_longform/display.ts
function split_display(display_elts, make_obj, class_regexp, settings) {
  const new_display = [];
  for (const elt of display_elts) {
    if (elt instanceof Paragraph) {
      console.assert(
        elt.elements.length == 1,
        "Paragraph should have only one element at this stage of parsing"
      );
      console.assert(
        elt.elements[0] instanceof Text,
        "Paragraph should have only one text element at this stage of parsing"
      );
      const inline_element = elt.elements[0];
      let current_match = null;
      let start_index = 0;
      const string_to_parse = inline_element.content;
      while ((current_match = class_regexp.exec(string_to_parse)) !== null) {
        if (current_match.index == void 0) {
          throw new Error("current_match.index is undefined");
        }
        const prev_chunk = inline_element.content.slice(
          start_index,
          current_match.index
        );
        if (prev_chunk.trim() !== "") {
          new_display.push(
            new Paragraph([new Text(strip_newlines(prev_chunk))])
          );
        }
        new_display.push(make_obj(current_match, settings));
        start_index = current_match.index + current_match[0].length;
      }
      const return_string = strip_newlines(
        inline_element.content.slice(start_index)
      );
      if (return_string.trim() !== "") {
        new_display.push(new Paragraph([new Text(return_string)]));
      }
    } else {
      new_display.push(elt);
    }
  }
  return new_display;
}
var DisplayMath = class {
  static get_regexp() {
    return /\$\$\s*(?:\\begin{(\S*?)}\s*([\S\s]*?)\s*\\end{\1}|([\S\s]*?))\s*?\$\$(?:\s*?{#(\S*?)})?/gs;
  }
  static build_from_match(match, settings) {
    const latex = match[2] === void 0 ? match[3] : match[2];
    const label_match = /eq-(\w+)/.exec(match[1]);
    let label_val = match[1];
    if (label_match && label_match[1] !== void 0) {
      label_val = label_match[1];
    }
    return new DisplayMath(latex, match[4], label_val);
  }
  constructor(latex, label, explicit_env) {
    this.content = latex;
    this.label = label;
    this.explicit_env_name = explicit_env;
  }
  async unroll(data) {
    this.file_of_origin = data.current_file;
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    let env_name = "equation*";
    if (this.label !== void 0) {
      env_name = "equation";
      if (this.explicit_env_name !== void 0 && ["equation*", "align*"].includes(this.explicit_env_name)) {
        notice_and_warn(
          `Environment ${this.explicit_env_name} does not support labels.
 Ignoring label ${this.label}
In note:
` + this.file_of_origin.path
        );
      }
      if (this.explicit_env_name !== void 0 && ["align"].includes(this.explicit_env_name)) {
        const label = format_label(this.label);
        const lines = this.content.split("\\\\");
        const numlines = lines.length;
        const labeled_lines = [];
        lines.forEach((line, index) => {
          if (line.trim() !== "") {
            let new_text = line + ` \\label{${label}:${index + 1}}`;
            if (index < numlines - 1) {
              new_text += "\\\\";
            }
            labeled_lines.push(new_text);
          }
        });
        this.content = labeled_lines.join("");
      } else {
        this.content = "\\label{" + format_label(this.label) + "}\n" + this.content;
      }
    }
    if (this.explicit_env_name !== void 0) {
      if ([
        "equation",
        "equation*",
        "align",
        "align*",
        "multline",
        "multline*",
        "gather",
        "gather*"
      ].includes(this.explicit_env_name)) {
        env_name = this.explicit_env_name;
      } else {
        this.content = "\\begin{" + this.explicit_env_name + "}\n" + this.content + "\n\\end{" + this.explicit_env_name + "}";
      }
    }
    buffer_offset += buffer.write(
      "\\begin{" + env_name + "}\n",
      buffer_offset
    );
    buffer_offset += buffer.write(this.content + "\n", buffer_offset);
    buffer_offset += buffer.write(
      "\\end{" + env_name + "}\n",
      buffer_offset
    );
    return buffer_offset;
  }
};
var Paragraph = class {
  constructor(elements) {
    this.elements = elements;
  }
  async unroll(data, settings) {
    const new_elements = [];
    for (const elt of this.elements) {
      new_elements.push(...await elt.unroll(data, settings));
    }
    this.elements = new_elements;
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    let new_offset = buffer_offset;
    for (const elt of this.elements) {
      new_offset = await elt.latex(buffer, new_offset, settings);
    }
    new_offset += buffer.write("\n", new_offset);
    return new_offset;
  }
};
var BlankLine = class {
  static get_regexp() {
    return /\n\s*\n/g;
  }
  static build_from_match() {
    return new BlankLine();
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("\n", buffer_offset);
  }
};
var DisplayCode = class {
  static get_regexp() {
    return /```(?:\s*({?)([a-zA-Z]+)(}?)\s*\n([\s\S]*?)|([\s\S]*?))```/g;
  }
  static build_from_match(match, settings) {
    if (match[4] !== void 0) {
      const code = match[4];
      const executable = match[1] == "{" && match[3] == "}";
      const language = match[2] !== "" ? match[2] : void 0;
      return new DisplayCode(code, language, executable);
    } else {
      const code = match[5];
      return new DisplayCode(code);
    }
  }
  constructor(code, language, executable = false) {
    this.code = code;
    this.language = language;
    this.executable = executable;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    buffer_offset += buffer.write("\\begin{verbatim}", buffer_offset);
    buffer_offset += buffer.write(this.code, buffer_offset);
    buffer_offset += buffer.write("\\end{verbatim}\n", buffer_offset);
    return buffer_offset;
  }
};
var Quote = class {
  static get_regexp() {
    return /^>(.*)$/gm;
  }
  constructor(content) {
    this.content = content;
  }
  static build_from_match(regexmatch, settings) {
    return new Quote(regexmatch[1]);
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("%" + this.content + "\n", buffer_offset);
  }
};
var NumberedList = class {
  static get_regexp() {
    return /(?<=^|\n)[ \t]*?1\. (.*?)(?:2\. (.*?))?(?:3\. (.*?))?(?:4\. (.*?))?(?:5\. (.*?))?(?:6\. (.*?))?(?:7\. (.*?))?(?:8\. (.*?))?(?:9\. (.*?))?(?:10\. (.*?))?(?:11\. (.*?))?(?:12\. (.*?))?(?:13\. (.*?))?(?:14\. (.*?))?(?:15\. (.*?))?(?:16\. (.*?))?(?:17\. (.*?))?(?:18\. (.*?))?(?:19\. (.*?))?(?:20\. (.*?))?$/gs;
  }
  constructor(content) {
    this.content = content;
  }
  static build_from_match(regexmatch, settings) {
    const list_contents = [];
    for (const e of regexmatch.slice(1)) {
      if (e === void 0) {
        break;
      }
      list_contents.push(e);
    }
    return new NumberedList(
      list_contents.map((e) => [new Paragraph([new Text(e)])])
    );
  }
  async unroll(data, settings) {
    const new_content = [];
    for (const e of this.content) {
      new_content.push(await unroll_array(data, e, settings));
    }
    return [new NumberedList(new_content)];
  }
  async latex(buffer, buffer_offset, settings) {
    buffer_offset += buffer.write("\\begin{enumerate}\n", buffer_offset);
    for (const e of this.content) {
      buffer_offset += buffer.write("\\item ", buffer_offset);
      for (const f of e) {
        buffer_offset = await f.latex(buffer, buffer_offset, settings);
      }
    }
    buffer_offset += buffer.write("\\end{enumerate}\n", buffer_offset);
    return buffer_offset;
  }
};
var UnorderedList = class {
  static get_regexp() {
    return /(?<=^|\n)[ \t]*?(?:-|\+|\*) (.*?)(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?$/gs;
  }
  constructor(content) {
    this.content = content;
  }
  static build_from_match(regexmatch, settings) {
    const list_contents = [];
    for (const e of regexmatch.slice(1)) {
      if (e === void 0) {
        break;
      }
      list_contents.push(e);
    }
    return new UnorderedList(
      list_contents.map((e) => [new Paragraph([new Text(e)])])
    );
  }
  async unroll(data, settings) {
    const new_content = [];
    for (const e of this.content) {
      new_content.push(await unroll_array(data, e, settings));
    }
    return [new UnorderedList(new_content)];
  }
  async latex(buffer, buffer_offset, settings) {
    buffer_offset += buffer.write("\\begin{itemize}\n", buffer_offset);
    for (const e of this.content) {
      buffer_offset += buffer.write("\\item ", buffer_offset);
      for (const f of e) {
        buffer_offset = await f.latex(buffer, buffer_offset, settings);
      }
    }
    buffer_offset += buffer.write("\\end{itemize}\n", buffer_offset);
    return buffer_offset;
  }
};
var Comment = class {
  static get_regexp() {
    return /\%\%(.*?)\%\%/gs;
  }
  constructor(content) {
    this.content = content;
  }
  static build_from_match(regexmatch, settings) {
    return new Comment(regexmatch[1]);
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset;
  }
};

// src/export_longform/wikilinks.ts
var import_obsidian2 = require("obsidian");
var import_console = require("console");
var EmbedWikilink = class {
  static get_regexp() {
    return /(?:(\S*?)::)?!\[\[([\s\S]*?)(?:#([\s\S]+?))?(?:\|([\s\S]*?))?\]\]/g;
  }
  static build_from_match(args, settings) {
    return new EmbedWikilink(args[1], args[2], args[3], args[4]);
  }
  constructor(attribute, address, header, displayed) {
    this.attribute = attribute;
    this.content = address;
    this.header = header;
    this.display = displayed;
  }
  async unroll(data, settings) {
    if (address_is_image_file(this.content)) {
      const file = find_image_file(data.find_file, this.content);
      if (file === void 0) {
        const err_msg = "Content not found: Could not find the content of the plot with image '" + escape_latex(this.content) + "'";
        notice_and_warn(err_msg);
        return [
          new BlankLine(),
          new Paragraph([new Text(err_msg)]),
          new BlankLine()
        ];
      } else {
        data.media_files.push(file);
        const p = new Plot(file, data.current_file, this.display);
        p.label = await label_from_location(
          data,
          file.name,
          data.current_file,
          settings
        );
        return [p];
      }
    }
    const return_data = await parse_embed_content(
      this.content,
      data.find_file,
      data.read_tfile,
      data.parsed_file_bundle,
      data.current_file,
      settings,
      this.header
    );
    if (return_data === void 0) {
      const err_msg = "Content not found: Could not find the content of \\emph{" + escape_latex(this.content) + "} with header \\emph{" + this.header + "}";
      const other_err_msg = "Content not found: Could not find the content of '" + escape_latex(this.content) + "' with header '" + this.header + "'";
      new import_obsidian2.Notice(other_err_msg);
      return [
        new BlankLine(),
        new Paragraph([new Text(err_msg)]),
        new BlankLine()
      ];
    }
    const [
      parsed_contents,
      level_of_header_being_embedded,
      embedded_file_yaml
    ] = return_data;
    const ambient_header_level_outside = data.ambient_header_level;
    const ambient_header_offset_outside = data.headers_level_offset;
    const ambient_header_stack = data.header_stack;
    data.header_stack = [];
    data.headers_level_offset = data.ambient_header_level - level_of_header_being_embedded;
    const unrolled_contents = [];
    const was_in_thm_env = data.in_thm_env;
    if (this.attribute !== void 0) {
      data.in_thm_env = true;
    }
    const candidate_file = data.find_file(this.content);
    if (candidate_file === void 0) {
      throw new Error("Could not find file: " + this.content);
    }
    const ambient_current_file = data.current_file;
    data.current_file = candidate_file;
    for (const elt of parsed_contents) {
      unrolled_contents.push(...await elt.unroll(data, settings));
    }
    if (!was_in_thm_env) {
      data.in_thm_env = false;
    }
    data.ambient_header_level = ambient_header_level_outside;
    data.headers_level_offset = ambient_header_offset_outside;
    data.current_file = ambient_current_file;
    data.header_stack = ambient_header_stack;
    const address = this.content === "" ? data.longform_file.basename : this.content;
    if (this.attribute !== void 0) {
      return [
        new Environment(
          unrolled_contents,
          this.attribute,
          await label_from_location(
            data,
            address,
            data.current_file,
            settings,
            this.header
          ),
          address,
          embedded_file_yaml,
          this.display
        )
      ];
    }
    return unrolled_contents;
  }
  async latex(buffer, buffer_offset, settings) {
    console.error(
      "Embed wikilink " + this.content + "should have been unrolled to something else"
    );
    return 0;
  }
};
var Plot = class {
  constructor(image, current_file, caption) {
    this.file_of_origin = current_file;
    this.image = image;
    this.caption = caption;
  }
  async unroll(data) {
    this.file_of_origin = data.current_file;
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    buffer_offset += buffer.write(
      `\\begin{figure}[h]
\\centering
\\includegraphics[width=\\textwidth]{Files/` + this.image.name + "}\n",
      // Cannot use path.join, because the path is a latex path.
      buffer_offset
    );
    let caption_text;
    if (this.caption === void 0) {
      caption_text = "";
      const warning = "WARNING: Figure created from '" + this.image.name + "' has no caption.\nYou may want to add one in the display part of the wikilink: for example,\n![[plot.png|my caption]]\nIn note:\n" + this.file_of_origin.path;
      notice_and_warn(warning);
    } else {
      caption_text = this.caption;
    }
    buffer_offset += buffer.write(
      "\\caption{" + caption_text + "\\label{" + this.label + "}}\n",
      buffer_offset
    );
    buffer_offset += buffer.write("\\end{figure}\n", buffer_offset);
    return buffer_offset;
  }
};
var Wikilink = class {
  static get_regexp() {
    return /(?:(\S*?)::)?\[\[([\s\S]*?)(?:\#([\s\S]*?))?(?:\|([\s\S]*?))?\]\]/g;
  }
  static build_from_match(args, settings) {
    return new Wikilink(args[1], args[2], args[3], args[4]);
  }
  constructor(attribute, address, header, displayed) {
    this.attribute = attribute;
    this.content = address;
    this.header = header;
    this.displayed = displayed;
  }
  async unroll(data, settings) {
    if (this.content === "" && this.header !== void 0) {
      this.content = data.current_file.basename;
    }
    return [
      new UnrolledWikilink(
        data,
        this.attribute,
        this.content,
        this.header,
        this.displayed
      )
    ];
  }
  async latex(buffer, buffer_offset, settings) {
    if (this.header === void 0) {
      this.header = "";
    }
    return buffer_offset + buffer.write(
      "[[" + this.content + "#" + this.header + "]]",
      buffer_offset
    );
  }
};
var Environment = class {
  // Can parse a label as well
  static get_regexp() {
    return /^(\w+?)::(?:\s*?{#([\S ]*?)})?(.*?)::\1/gms;
  }
  constructor(children, type, label, address_of_origin, embedded_file_yaml, display_title) {
    this.children = children;
    this.type = type.toLowerCase().trim();
    this.label = label;
    this.address_of_origin = address_of_origin;
    this.embedded_file_yaml = embedded_file_yaml;
    this.display_title = display_title;
  }
  static build_from_match(match, settings) {
    let [_, body] = parse_display(strip_newlines(match[3]), settings);
    body = parse_after_headers(body, settings);
    traverse_tree_and_parse_inline(body, settings);
    return new Environment(
      // Here we must run a full parsing on the contents instead of inserting a string.
      // parse_note(strip_newlines(match[3])).body,
      body,
      match[1],
      match[2]
    );
  }
  async unroll(data, settings) {
    if (this.label !== void 0) {
      this.label = explicit_label(
        data.longform_file,
        data.current_file,
        this.label
      );
    }
    this.address_of_origin = void 0;
    this.children = await unroll_array(data, this.children, settings);
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    let start_env_string = "\\begin{" + this.type + "}";
    if (this.type === "proof" && this.label !== void 0) {
      start_env_string += "[\\hypertarget{" + this.label + "}Proof of \\Cref{" + this.label.replace("proof", "statement") + "}]";
    } else if (this.type !== "remark" && settings.display_env_titles) {
      if (this.display_title !== void 0) {
        if (this.display_title !== "") {
          start_env_string += "[" + this.display_title + "]";
        }
      } else if (this.embedded_file_yaml !== void 0 && this.embedded_file_yaml.env_title !== void 0) {
        if (this.embedded_file_yaml.env_title !== "" && this.embedded_file_yaml.env_title !== null) {
          start_env_string += "[" + this.embedded_file_yaml.env_title + "]";
        }
      } else if (settings.default_env_name_to_file_name && this.address_of_origin !== void 0) {
        start_env_string += "[" + this.address_of_origin + "]";
      }
    }
    buffer_offset += buffer.write(start_env_string + "\n", buffer_offset);
    if (this.label !== void 0 && this.type !== "proof") {
      buffer_offset += buffer.write(
        "\\label{" + format_label(this.label) + "}\n",
        buffer_offset
      );
    } else {
      buffer_offset += buffer.write("\n", buffer_offset);
    }
    for (const e of this.children) {
      buffer_offset = await e.latex(buffer, buffer_offset, settings);
    }
    buffer_offset += buffer.write(
      "\\end{" + this.type + "}\n",
      buffer_offset
    );
    return buffer_offset;
  }
};
var Hyperlink = class {
  static get_regexp() {
    return /\[([^\[\]]+?)\]\((https?:\/\/[^\s]+?)\)/g;
  }
  static build_from_match(args, settings) {
    return new Hyperlink(args[1], args[2]);
  }
  constructor(label, address) {
    this.label = label;
    this.address = address;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write(
      `\\href{${this.address}}{${this.label}}`,
      buffer_offset
    );
  }
};
var UnrolledWikilink = class {
  constructor(unroll_data, attribute, address, header, displayed) {
    (0, import_console.assert)(!/^@/.exec(address), "Should not be a citation");
    this.unroll_data = {
      in_thm_env: unroll_data.in_thm_env,
      depth: unroll_data.depth,
      env_hash_list: unroll_data.env_hash_list,
      parsed_file_bundle: unroll_data.parsed_file_bundle,
      ambient_header_level: unroll_data.ambient_header_level,
      headers_level_offset: unroll_data.headers_level_offset,
      explicit_env_index: unroll_data.explicit_env_index,
      find_file: unroll_data.find_file,
      read_tfile: unroll_data.read_tfile,
      longform_file: unroll_data.longform_file,
      current_file: unroll_data.current_file,
      header_stack: [...unroll_data.header_stack],
      media_files: [...unroll_data.media_files],
      bib_keys: [...unroll_data.bib_keys]
    };
    this.address = address;
    this.attribute = attribute;
    this.address = address;
    this.header = header;
    this.displayed = displayed;
  }
  async latex(buffer, buffer_offset, settings) {
    var _a, _b;
    const hasBeenEmbedded = this.unroll_data.parsed_file_bundle[this.address] !== void 0;
    const file = this.unroll_data.find_file(this.address);
    if (!file) {
      notice_and_warn(
        "Wikilink with address '" + this.address + "' points to no file. Wikilink is in file: '" + this.unroll_data.current_file.path + "'"
      );
      return buffer_offset + buffer.write(
        "FAILED TO RESOLVE:[[" + this.address + "]]",
        buffer_offset
      );
    }
    if (!hasBeenEmbedded && !address_is_image_file(this.address) && (!this.header || this.header.toLowerCase() === "statement")) {
      const file_contents = await this.unroll_data.read_tfile(file);
      const [yaml] = parse_yaml_header(file_contents);
      const bib_key_match = (_a = yaml.source) == null ? void 0 : _a.match(
        /@([a-zA-Z0-9\-_]+)|\[\[@([a-zA-Z0-9\-_]+)\]\]/
      );
      const bib_key = bib_key_match ? bib_key_match[1] || bib_key_match[2] : void 0;
      const published_result_name = yaml.published_result_name;
      if (bib_key && typeof published_result_name === "string") {
        const citation = new Citation(
          bib_key,
          "std",
          published_result_name || this.displayed
        );
        return citation.latex(buffer, buffer_offset, settings);
      } else {
        notice_and_warn(
          "address of reference '" + this.address + "' is referenced but was not embedded.\nIn note:\n" + this.unroll_data.current_file.path
        );
        return buffer_offset + buffer.write(
          "FAILED TO RESOLVE:[[" + this.address + "]]",
          buffer_offset
        );
      }
    }
    const label = await label_from_location(
      this.unroll_data,
      this.address,
      this.unroll_data.current_file,
      settings,
      this.header
    );
    if (this.displayed !== void 0) {
      return buffer_offset + buffer.write(
        "\\hyperref[" + label + "]{" + this.displayed + "}",
        buffer_offset
      );
    }
    if (((_b = this.header) == null ? void 0 : _b.toLowerCase().trim()) !== "proof") {
      return buffer_offset + buffer.write("\\Cref{" + label + "}", buffer_offset);
    } else {
      return buffer_offset + buffer.write(
        "\\hyperlink{" + label + "}{the proof}",
        buffer_offset
      );
    }
  }
  async unroll() {
    return [this];
  }
};
var PandocCitation = class {
  static get_regexp() {
    return /(?:(?:@([^,.;\[\] ]+))|(?:\[(-)?@([^,;.\[\]\- ]+)(?:, ?([^\]\[]*))?\]))(?:\[([^\]@]*)\])?/g;
  }
  constructor(id, type, suffix) {
    this.id = id;
    this.type = type;
    this.result = suffix;
  }
  static build_from_match(args, settings) {
    let bibkey = void 0;
    let enclosed_in_brackets;
    if (args[1] != void 0) {
      bibkey = args[1];
      enclosed_in_brackets = false;
    } else if (args[3] != void 0) {
      bibkey = args[3];
      enclosed_in_brackets = true;
    } else {
      throw Error("Unexpected regex behaviour; no bibkey found");
    }
    let suffix = void 0;
    if (args[4] !== void 0) {
      suffix = args[4];
    } else if (args[5] !== void 0) {
      suffix = args[5];
    }
    const supressed = args[2] !== void 0;
    let citation_type;
    if (supressed) {
      citation_type = "year";
    } else if (enclosed_in_brackets) {
      citation_type = "parenthesis";
    } else {
      citation_type = "txt";
    }
    if (suffix == "std" || suffix == "txt") {
      citation_type = suffix;
      suffix = void 0;
    }
    return new Citation(bibkey, citation_type, suffix);
  }
  async unroll() {
    throw Error("Should not be unrolled.");
  }
  async latex(buffer, buffer_offset, settings) {
    throw Error("Latex on this PandocCitation should not be called.");
  }
};
var Citation = class {
  static get_regexp() {
    return /(?:\[([^@\[]*?)\])?(?:(?:\[\[@([a-zA-Z0-9\.\-_]*)\]\]))(?:\[([^@\[]*?)\])?/g;
  }
  static build_from_match(args, settings) {
    let captured_id = args[2];
    if (captured_id == "") {
      throw new Error("Unexpected: empty match for citation id.");
    }
    let type = void 0;
    let result = void 0;
    if (args[1] !== void 0) {
      result = args[1];
    } else if (args[3] !== void 0) {
      result = args[3];
    }
    if (result == "std" || result == "txt") {
      type = result;
      result = void 0;
    }
    return new Citation(captured_id, type, result);
  }
  constructor(id, type, suffix) {
    if (!(type == void 0 || type == "txt" || type == "std" || type == "year" || type == "parenthesis")) {
      notice_and_warn(
        "Invalid citation type: " + type + ". Reverting to default."
      );
      this.type = void 0;
    } else {
      this.type = type;
    }
    this.id = id;
    this.result = suffix;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    let citestring = "\\";
    let citeword;
    if (this.type == "txt") {
      citeword = "textcite";
    } else if (this.type == "std") {
      citeword = "cite";
    } else if (this.type == "parenthesis") {
      citeword = "parencite";
    } else if (this.type == "year") {
      citeword = "citeyear";
    } else if (this.type == void 0) {
      citeword = settings.default_citation_command;
    } else {
      throw Error("Invalid type: " + this.type);
    }
    citestring += citeword;
    if (this.result !== void 0) {
      citestring += "[" + this.result + "]";
    }
    citestring += "{" + this.id + "}";
    return buffer_offset + buffer.write(citestring, buffer_offset);
  }
};
var MultiCitation = class {
  static get_regexp() {
    return /(?:\[std\])?\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\]\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\](?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?/g;
  }
  static build_from_match(args) {
    return new MultiCitation(args);
  }
  constructor(args) {
    this.ids = [];
    for (const id of args.slice(1)) {
      if (id === void 0) {
        break;
      }
      this.ids.push(id);
    }
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset) {
    buffer_offset += buffer.write("\\cite{", buffer_offset);
    for (const id of this.ids.slice(0, -1)) {
      buffer_offset += buffer.write(id + ", ", buffer_offset);
    }
    buffer_offset += buffer.write(
      this.ids[this.ids.length - 1] + "}",
      buffer_offset
    );
    return buffer_offset;
  }
};
var PandocMultiCitation = class {
  static get_regexp() {
    return /(?<!\[)(\[)?@([a-zA-Z0-9\-_]+);[ \t]*(?:@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?\]?/g;
  }
  static build_from_match(args) {
    return new PandocMultiCitation(args);
  }
  constructor(args) {
    this.ids = [];
    if (args[1] !== void 0) {
      this.type = "parenthesis";
    } else {
      this.type = "std";
    }
    for (const id of args.slice(2)) {
      if (id === void 0) {
        break;
      }
      this.ids.push(id);
    }
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset) {
    let citeword = "cite";
    if (this.type == "parenthesis") {
      citeword = "parencite";
    }
    buffer_offset += buffer.write("\\" + citeword + "{", buffer_offset);
    for (const id of this.ids.slice(0, -1)) {
      buffer_offset += buffer.write(id + ", ", buffer_offset);
    }
    buffer_offset += buffer.write(
      this.ids[this.ids.length - 1] + "}",
      buffer_offset
    );
    return buffer_offset;
  }
};

// src/export_longform/parseMarkdown.ts
var import_obsidian3 = require("obsidian");
async function parse_longform(read_tfile, find_file, longform_file, settings, selection) {
  let file_contents;
  if (selection === void 0) {
    file_contents = await read_tfile(longform_file);
  } else {
    file_contents = selection;
  }
  const parsed_longform2 = parse_note(file_contents, settings);
  const cache = {};
  cache[longform_file.basename] = parsed_longform2;
  let parsed_content = parsed_longform2.body;
  let abstract_header;
  for (const e of parsed_content) {
    if (e instanceof Header && (await e.latex_title(settings)).toLowerCase().trim() === "abstract") {
      abstract_header = e;
      parsed_content = parsed_content.filter((x) => x !== e);
    }
  }
  let appendix_header;
  for (const e of parsed_content) {
    if (e instanceof Header && (await e.latex_title(settings)).toLowerCase().trim() === "appendix") {
      appendix_header = e;
      parsed_content = parsed_content.filter((x) => x !== e);
    }
  }
  let body_header_content = parsed_content;
  let body_header = void 0;
  for (const e of parsed_content) {
    if (e instanceof Header && (await e.latex_title(settings)).toLowerCase().trim() === "body") {
      body_header = e;
      lower_headers([body_header]);
      body_header_content = e.children;
    }
  }
  const data = init_data(longform_file, read_tfile, find_file);
  data.parsed_file_bundle = cache;
  if (abstract_header !== void 0) {
    data.header_stack = [abstract_header];
  }
  const abstract_unrolled_content = abstract_header === void 0 ? void 0 : await unroll_array(data, abstract_header.children, settings);
  if (body_header !== void 0) {
    data.header_stack = [body_header];
  }
  const body_unrolled_content = await unroll_array(
    data,
    body_header_content,
    settings
  );
  if (appendix_header !== void 0) {
    data.header_stack = [appendix_header];
  }
  const appendix_unrolled_content = appendix_header === void 0 ? void 0 : await unroll_array(data, appendix_header.children, settings);
  const abstract_string = abstract_unrolled_content === void 0 ? void 0 : await render_content(data, abstract_unrolled_content, settings);
  const body_string = await render_content(
    data,
    body_unrolled_content,
    settings
  );
  const appendix_string = appendix_unrolled_content === void 0 ? void 0 : await render_content(data, appendix_unrolled_content, settings);
  return {
    yaml: parsed_longform2.yaml,
    abstract: abstract_string,
    body: body_string,
    appendix: appendix_string,
    media_files: data.media_files,
    bib_keys: data.bib_keys
  };
}
function lower_headers(content) {
  for (const e of content) {
    if (e instanceof Header) {
      e.level -= 1;
      lower_headers(e.children);
    }
  }
}
async function render_content(data, content, settings) {
  const buffer = Buffer.alloc(1e7);
  let offset = 0;
  for (const elt of content) {
    offset = await elt.latex(buffer, offset, settings);
  }
  return buffer.toString("utf8", 0, offset);
}
async function export_selection(read_tfile, find_file, longform_file, selection, settings) {
  const parsed_contents = await parse_longform(
    read_tfile,
    find_file,
    longform_file,
    settings,
    selection
  );
  if (selection !== void 0) {
    const content = join_sections(parsed_contents);
    await navigator.clipboard.writeText(content);
    new import_obsidian3.Notice("Latex content copied to clipboard");
    return;
  }
}
async function write_with_template(template_file, parsed_contents, output_file, modify_tfile, read_tfile) {
  let template_content = await read_tfile(template_file);
  for (const key of Object.keys(parsed_contents["yaml"])) {
    template_content = template_content.replace(
      RegExp(`\\$${key}\\$`, "i"),
      parsed_contents["yaml"][key]
    );
  }
  template_content = template_content.replace(
    /\$body\$/i,
    parsed_contents["body"]
  );
  if (parsed_contents["abstract"] !== void 0) {
    if (template_file) {
      template_content = template_content.replace(
        /\$abstract\$/i,
        parsed_contents["abstract"]
      );
    } else {
      template_content;
    }
  }
  if (parsed_contents["appendix"] !== void 0) {
    template_content = template_content.replace(
      /\$appendix\$/i,
      parsed_contents["appendix"]
    );
  }
  await modify_tfile(output_file, template_content);
}
function join_sections(parsed_contents) {
  let content = "";
  if (parsed_contents["abstract"] !== void 0) {
    content = content + `\\begin{abstract}
` + parsed_contents["abstract"] + `\\end{abstract}
`;
  }
  content += parsed_contents["body"];
  if (parsed_contents["appendix"] !== void 0) {
    content += `\\printbibliography
`;
    content += `\\appendix
\\section{Appendix}
` + parsed_contents["appendix"];
  }
  return content;
}
async function write_without_template(parsed_contents, output_file, modify, preamble_file) {
  let content = `\\documentclass{article}
\\input{header}
`;
  if (preamble_file !== void 0) {
    content += "\\input{" + preamble_file.name + "}\n";
  }
  content += `\\addbibresource{bibliography.bib}
`;
  content += `\\title{`;
  if (parsed_contents["yaml"]["title"] !== void 0) {
    content += parsed_contents["yaml"]["title"];
  }
  content += `}
`;
  if (parsed_contents["yaml"]["author"] !== void 0) {
    content += `\\author{` + parsed_contents["yaml"]["author"] + `}
`;
  }
  content += `\\begin{document}
\\maketitle
`;
  if (parsed_contents["abstract"] !== void 0) {
    content = content + `\\begin{abstract}
` + parsed_contents["abstract"] + `\\end{abstract}
`;
  }
  content += parsed_contents["body"] + `\\printbibliography
`;
  if (parsed_contents["appendix"] !== void 0) {
    content += `\\appendix
\\section{Appendix}
` + parsed_contents["appendix"];
  }
  content += "\\end{document}\n";
  await modify(output_file, content);
}
function traverse_tree_and_parse_display(md, settings) {
  const new_md = [];
  for (const elt of md) {
    if (elt instanceof Paragraph) {
      const parsed_objects = parse_after_headers([elt], settings);
      new_md.push(...parsed_objects);
    } else if (elt instanceof Header) {
      elt.children = traverse_tree_and_parse_display(
        elt.children,
        settings
      );
      new_md.push(elt);
    } else {
      new_md.push(elt);
    }
  }
  return new_md;
}
function traverse_tree_and_parse_inline(md, settings) {
  for (const elt of md) {
    if (elt instanceof Header) {
      traverse_tree_and_parse_inline(elt.children, settings);
      elt.title = parse_inline(elt.title, settings);
    } else if (elt instanceof NumberedList) {
      for (const e of elt.content) {
        traverse_tree_and_parse_inline(e, settings);
      }
    } else if (elt instanceof UnorderedList) {
      for (const e of elt.content) {
        traverse_tree_and_parse_inline(e, settings);
      }
    } else if (elt instanceof Paragraph) {
      elt.elements = parse_inline(elt.elements, settings);
    }
  }
}
function parse_note(file_contents, settings) {
  const [yaml, body] = parse_display(file_contents, settings);
  let parsed_contents = make_heading_tree(body);
  parsed_contents = traverse_tree_and_parse_display(
    parsed_contents,
    settings
  );
  traverse_tree_and_parse_inline(parsed_contents, settings);
  return { yaml, body: parsed_contents };
}
async function parse_embed_content(address, find_file, read_tfile, parsed_cache, file_of_origin, settings, header) {
  const file_found = find_file(address);
  if (file_found === void 0) {
    return void 0;
  }
  if (!(file_found.basename in Object.keys(parsed_cache))) {
    const file_contents = await read_tfile(file_found);
    parsed_cache[file_found.basename] = parse_note(file_contents, settings);
  }
  const content = parsed_cache[file_found.basename];
  if (content === void 0) {
    return void 0;
  }
  if (header === void 0) {
    return [content.body, 0, content.yaml];
  }
  const header_elt = await find_header(header, [content.body], settings);
  if (header_elt === void 0) {
    notice_and_warn(
      "Header not found: " + header + " in file with address " + address + "In note:\n" + file_of_origin.path
    );
    return void 0;
  }
  return [header_elt.children, header_elt.level, content.yaml];
}
function parse_display(input, settings) {
  const parsed_yaml = parse_yaml_header(input);
  let new_display = [new Paragraph([new Text(parsed_yaml[1])])];
  new_display = split_display(
    new_display,
    Comment.build_from_match,
    Comment.get_regexp(),
    settings
  );
  new_display = split_display(
    new_display,
    Quote.build_from_match,
    Quote.get_regexp(),
    settings
  );
  new_display = split_display(
    new_display,
    DisplayCode.build_from_match,
    DisplayCode.get_regexp(),
    settings
  );
  new_display = split_display(
    new_display,
    EmbedWikilink.build_from_match,
    EmbedWikilink.get_regexp(),
    settings
  );
  return [parsed_yaml[0], new_display];
}
function parse_after_headers(new_display, settings) {
  new_display = split_display(
    new_display,
    Environment.build_from_match,
    Environment.get_regexp(),
    settings
  );
  new_display = split_display(
    new_display,
    BlankLine.build_from_match,
    BlankLine.get_regexp(),
    settings
  );
  if (!settings.prioritize_lists) {
    new_display = split_display(
      new_display,
      DisplayMath.build_from_match,
      DisplayMath.get_regexp(),
      settings
    );
  }
  new_display = split_display(
    // Lists parse until the end of the string. What limits them is the presence of other elements in front of them.
    new_display,
    NumberedList.build_from_match,
    NumberedList.get_regexp(),
    settings
  );
  for (const elt of new_display) {
    if (elt instanceof NumberedList) {
      const new_content = [];
      for (const e of elt.content) {
        new_content.push(parse_after_headers(e, settings));
      }
      elt.content = new_content;
    }
  }
  new_display = split_display(
    new_display,
    UnorderedList.build_from_match,
    UnorderedList.get_regexp(),
    settings
  );
  for (const elt of new_display) {
    if (elt instanceof UnorderedList) {
      const new_content = [];
      for (const e of elt.content) {
        new_content.push(parse_after_headers(e, settings));
      }
      elt.content = new_content;
    }
  }
  if (settings.prioritize_lists) {
    new_display = split_display(
      new_display,
      DisplayMath.build_from_match,
      DisplayMath.get_regexp(),
      settings
    );
  }
  return new_display;
}
var ZeroHeader = class {
  constructor(content) {
    this.level = 0;
    this.children = content;
  }
};
function make_heading_tree(markdown) {
  let headingRegex = /^(#+) (.*)$/gm;
  const new_md = new ZeroHeader([]);
  let header_stack = [];
  header_stack.push(new_md);
  let new_display = new_md.children;
  let current_match;
  for (const elt of markdown) {
    if (elt instanceof Paragraph) {
      console.assert(
        elt.elements.length == 1,
        "Paragraph should have only one element at this stage of parsing"
      );
      console.assert(
        elt.elements[0] instanceof Text,
        "Paragraph should have only one text element at this stage of parsing"
      );
      const inline_element = elt.elements[0];
      let start_index = 0;
      while ((current_match = headingRegex.exec(inline_element.content)) !== null) {
        if (current_match.index == void 0) {
          throw new Error("current_match.index is undefined");
        }
        const prev_chunk = inline_element.content.slice(
          start_index,
          current_match.index
        );
        if (prev_chunk.trim() !== "") {
          new_display.push(
            new Paragraph([new Text(strip_newlines(prev_chunk))])
          );
        }
        for (let i = header_stack.length - 1; i >= 0; i--) {
          const new_header = new Header(
            current_match[1].length,
            [new Text(current_match[2])],
            []
          );
          const level = new_header.level;
          if (level > header_stack[i].level) {
            header_stack.splice(
              i + 1,
              header_stack.length - (i + 1)
            );
            header_stack[i].children.push(new_header);
            header_stack.push(new_header);
            new_display = new_header.children;
            break;
          }
        }
        start_index = current_match.index + current_match[0].length;
      }
      const return_string = inline_element.content.slice(start_index);
      if (return_string.trim() !== "") {
        new_display.push(
          new Paragraph([new Text(strip_newlines(return_string))])
        );
      }
    } else {
      new_display.push(elt);
    }
  }
  return new_md.children;
}
function parse_yaml_header(input) {
  const match = /^---\n(.*?)---\n(.*)$/s.exec(input);
  if (!match) {
    return [{}, input];
  }
  return [(0, import_obsidian3.parseYaml)(match[1]), match[2]];
}
function parse_inline(inline_arr, settings) {
  inline_arr = split_inline(
    inline_arr,
    ExplicitRef.get_regexp(),
    ExplicitRef.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    MultiCitation.get_regexp(),
    MultiCitation.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    PandocMultiCitation.get_regexp(),
    PandocMultiCitation.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    Citation.get_regexp(),
    Citation.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    PandocCitation.get_regexp(),
    PandocCitation.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    Wikilink.get_regexp(),
    Wikilink.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    Hyperlink.get_regexp(),
    Hyperlink.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    InlineMath.get_regexp(),
    InlineMath.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    DoubleQuotes.get_regexp(),
    DoubleQuotes.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    SingleQuotes.get_regexp(),
    SingleQuotes.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    Strong.get_regexp(),
    Strong.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    Emphasis.get_regexp(),
    Emphasis.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    InlineCode.get_regexp(),
    InlineCode.build_from_match,
    settings
  );
  return inline_arr;
}

// src/export_longform/get_header_tex.ts
function get_header_tex() {
  return `\\usepackage{amsmath}
\\usepackage{amsthm}
\\usepackage{biblatex}
\\usepackage{graphicx}
\\usepackage{hyperref}
\\usepackage{cleveref}

\\theoremstyle{plain}
\\newtheorem{theorem}{Theorem}[section]
\\newtheorem{corollary}{Corollary}[section]
\\newtheorem{lemma}{Lemma}[section]
\\newtheorem{proposition}{Proposition}[section]

\\theoremstyle{definition}
\\newtheorem{definition}{Definition}[section]
\\newtheorem{example}{Example}

\\theoremstyle{remark}
\\newtheorem{remark}{Remark}[section]
\\newtheorem{fact}[remark]{Fact}`;
}

// src/main.ts
var { remote } = require("electron");
var ExportPaperPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.find_file = (address) => {
      const temp_result = this.app.metadataCache.getFirstLinkpathDest(
        address,
        "/"
      );
      if (temp_result) {
        return temp_result;
      } else {
        return void 0;
      }
    };
  }
  // External export method with FileSystemAdapter
  async export_to_external_folder(active_file, external_folder, skip_overwrite_check = false) {
    var _a, _b, _c;
    const parsed_contents = await parse_longform(
      this.app.vault.cachedRead.bind(this.app.vault),
      this.find_file,
      active_file,
      this.settings
    );
    const output_folder_name = active_file.basename.replace(/ /g, "_");
    const output_folder_path = path.join(
      external_folder,
      output_folder_name
    );
    const output_file_name = `${active_file.basename}_output.tex`;
    const output_path = path.join(output_folder_path, output_file_name);
    if (fs.existsSync(output_path) && !skip_overwrite_check && this.settings.warn_before_overwrite) {
      new WarningModal(
        this.app,
        this,
        () => this.export_to_external_folder(
          active_file,
          external_folder,
          true
        ),
        "It seems there is a previously exported file in the external folder. Overwrite it?"
      ).open();
      return;
    }
    if (!fs.existsSync(output_folder_path)) {
      fs.mkdirSync(output_folder_path, { recursive: true });
    }
    let export_message = "Exporting to external folder:\n";
    const preamble_file = (_a = this.app.vault.getFileByPath(this.settings.preamble_file)) != null ? _a : void 0;
    const new_preamble_path = path.join(output_folder_path, "preamble.sty");
    if (preamble_file) {
      const preamble_exists = fs.existsSync(new_preamble_path);
      if (this.settings.overwrite_preamble && preamble_exists) {
        fs.copyFileSync(
          this.app.vault.adapter.getFullPath(
            preamble_file.path
          ),
          new_preamble_path
        );
        export_message += "- Overwriting the preamble file\n";
      } else if (!preamble_exists) {
        fs.copyFileSync(
          this.app.vault.adapter.getFullPath(
            preamble_file.path
          ),
          new_preamble_path
        );
        export_message += "- Copying the preamble file\n";
      } else {
        export_message += "- Without overwriting the preamble file\n";
      }
    } else {
      export_message += "- Without a preamble file (none found)\n";
    }
    const header_path = path.join(output_folder_path, "header.tex");
    const header_exists = fs.existsSync(header_path);
    if (this.settings.overwrite_header && header_exists) {
      fs.writeFileSync(header_path, get_header_tex());
      export_message += "- Overwriting the header file\n";
    } else if (!header_exists) {
      fs.writeFileSync(header_path, get_header_tex());
      export_message += "- Creating the header file\n";
    } else {
      export_message += "- Without overwriting the header file\n";
    }
    const bib_file = (_b = this.app.vault.getFileByPath(this.settings.bib_file)) != null ? _b : void 0;
    const new_bib_path = path.join(output_folder_path, "bibliography.bib");
    if (bib_file) {
      const bib_exists = fs.existsSync(new_bib_path);
      if (!bib_exists) {
        fs.copyFileSync(
          this.app.vault.adapter.getFullPath(
            bib_file.path
          ),
          new_bib_path
        );
        export_message += "- Copying the bib file\n";
      } else {
        export_message += "- Without overwriting the bib file\n";
      }
    } else {
      export_message += "- Without a bib file (none found)\n";
    }
    const template_file = (_c = this.app.vault.getFileByPath(this.settings.template_path)) != null ? _c : void 0;
    if (template_file) {
      export_message += "- Using the specified template file,\n";
      await write_with_template(
        template_file,
        parsed_contents,
        { path: output_path },
        async (_file, content) => fs.writeFileSync(output_path, content),
        this.app.vault.cachedRead.bind(this.app.vault)
      );
    } else {
      await write_without_template(
        parsed_contents,
        { path: output_path },
        async (_file, content) => fs.writeFileSync(output_path, content),
        preamble_file
      );
    }
    if (parsed_contents.media_files.length > 0) {
      const files_folder = path.join(output_folder_path, "Files");
      if (!fs.existsSync(files_folder)) {
        fs.mkdirSync(files_folder);
      }
      let copying_message_added = false;
      let skipping_message_added = false;
      for (const media_file of parsed_contents.media_files) {
        const destination_path = path.join(
          files_folder,
          media_file.name
        );
        const file_exists = fs.existsSync(destination_path);
        if (this.settings.overwrite_figures && file_exists) {
          fs.copyFileSync(
            this.app.vault.adapter.getFullPath(media_file.path),
            destination_path
          );
          export_message += `- Overwriting figure file: ${media_file.name}
`;
        } else if (!file_exists) {
          fs.copyFileSync(
            this.app.vault.adapter.getFullPath(media_file.path),
            destination_path
          );
          if (!copying_message_added) {
            export_message += "- Copying figure files\n";
            copying_message_added = true;
          }
        } else if (!skipping_message_added) {
          export_message += "- Without overwriting figure files\n";
          skipping_message_added = true;
        }
      }
    }
    this.settings.last_external_folder = external_folder;
    await this.saveSettings();
    new import_obsidian4.Notice(
      `${export_message}To external folder: ${output_folder_path}`
    );
  }
  async find_files_and_export(active_file, settings) {
    if (this.settings.base_output_folder === "") {
      this.settings.base_output_folder = "/";
    }
    const notes_dir = this.app.vault;
    const parsed_contents = await parse_longform(
      notes_dir.cachedRead.bind(notes_dir),
      this.find_file,
      active_file,
      settings
    );
    let base_folder;
    if (parsed_contents.yaml["export_dir"] != null) {
      base_folder = this.app.vault.getFolderByPath(
        // parsed_contents.yaml["export_dir"],
        parsed_contents.yaml["export_dir"]
      );
    } else {
      base_folder = this.app.vault.getFolderByPath(
        this.settings.base_output_folder
      );
    }
    if (!base_folder) {
      notice_and_warn(
        "Output folder path not found, defaulting to the root of the vault."
      );
      base_folder = this.app.vault.getRoot();
    }
    const output_file_name = active_file.basename + "_output.tex";
    let output_folder_path = path.join(
      base_folder.path,
      active_file.basename.replace(/ /g, "_")
    );
    const output_folder_match = /^\/(.*)$/.exec(output_folder_path);
    if (output_folder_match) {
      output_folder_path = output_folder_match[1];
    }
    let output_path = path.join(output_folder_path, output_file_name);
    await this.app.vault.createFolder(output_folder_path).catch((e) => e);
    const the_preamble_file = this.app.vault.getFileByPath(
      this.settings.preamble_file
    );
    let export_message = "Exporting the current file:\n";
    const preamble_file = the_preamble_file ? the_preamble_file : void 0;
    if (preamble_file !== void 0) {
      const new_preamble = path.join(output_folder_path, "preamble.sty");
      const existing_preamble = this.app.vault.getFileByPath(new_preamble);
      if (this.settings.overwrite_preamble && existing_preamble) {
        await this.app.vault.delete(existing_preamble);
        await this.app.vault.copy(preamble_file, new_preamble);
        export_message += "- Overwriting the preamble file\n";
      } else if (!existing_preamble) {
        await this.app.vault.copy(preamble_file, new_preamble);
        export_message += "- Copying the preamble file\n";
      } else {
        export_message += "- Without overwriting the preamble file\n";
      }
    } else {
      export_message += " - Without a preamble file (none found)\n";
    }
    const header_path = path.join(output_folder_path, "header.tex");
    const header_file = this.app.vault.getFileByPath(header_path);
    if (this.settings.overwrite_header || !header_file) {
      if (header_file) {
        await this.app.vault.delete(header_file);
        export_message += "- Overwriting the header file\n";
      } else {
        export_message += "- Creating the header file\n";
      }
      await this.app.vault.create(header_path, get_header_tex());
    } else {
      export_message += "- Without overwriting the header file\n";
    }
    const the_bib_file = this.app.vault.getFileByPath(
      this.settings.bib_file
    );
    const bib_file = the_bib_file ? the_bib_file : void 0;
    if (bib_file !== void 0) {
      const new_bib = path.join(output_folder_path, "bibliography.bib");
      const existing_bib = this.app.vault.getFileByPath(new_bib);
      if (!existing_bib) {
        await this.app.vault.copy(bib_file, new_bib);
        export_message += "- Copying the bib file\n";
      } else {
        export_message += "- Without overwriting the bib file\n";
      }
    } else {
      export_message += "- Without a bib file (none found)\n";
    }
    const the_template_file = this.app.vault.getFileByPath(
      this.settings.template_path
    );
    const template_file = the_template_file !== null ? the_template_file : void 0;
    if (template_file !== void 0) {
      export_message += "- Using the specified template file,\n";
    }
    let out_file = this.app.vault.getFileByPath(output_path);
    if (out_file === null) {
      out_file = await this.app.vault.create(output_path, "");
      await this.proceed_with_export(
        active_file,
        parsed_contents,
        settings,
        output_folder_path,
        template_file,
        out_file,
        preamble_file,
        export_message
      );
    } else {
      const out_file_other = out_file;
      if (this.settings.warn_before_overwrite) {
        new WarningModal(
          this.app,
          this,
          () => this.proceed_with_export(
            active_file,
            parsed_contents,
            settings,
            output_folder_path,
            template_file,
            out_file_other,
            preamble_file,
            export_message
          ),
          "It seems there is a previously exported file. Overwrite it?"
        ).open();
      } else {
        await this.proceed_with_export(
          active_file,
          parsed_contents,
          settings,
          output_folder_path,
          template_file,
          out_file,
          preamble_file,
          export_message
        );
      }
    }
  }
  async proceed_with_export(active_file, parsed_contents, settings, output_folder_path, template_file, out_file, preamble_file, partial_message = "") {
    const notes_dir = this.app.vault;
    if (parsed_contents.media_files.length > 0) {
      const files_folder = path.join(output_folder_path, "Files");
      await this.app.vault.createFolder(files_folder).catch((e) => e);
      let copying_message_added = false;
      let skipping_message_added = false;
      for (const media_file of parsed_contents.media_files) {
        const destination_path = path.join(
          files_folder,
          media_file.name
        );
        const existing_file = this.app.vault.getFileByPath(destination_path);
        if (settings.overwrite_figures && existing_file) {
          await this.app.vault.delete(existing_file);
          await this.app.vault.copy(media_file, destination_path).catch((e) => e);
          partial_message += `- Overwriting figure file: ${media_file.name}
`;
        } else if (!existing_file) {
          await this.app.vault.copy(media_file, destination_path).catch((e) => e);
          if (!copying_message_added) {
            partial_message += "- Copying figure files\n";
            copying_message_added = true;
          }
        } else if (!skipping_message_added) {
          partial_message += "- Without overwriting figure files\n";
          skipping_message_added = true;
        }
      }
    }
    if (template_file !== void 0) {
      await write_with_template(
        template_file,
        parsed_contents,
        out_file,
        notes_dir.modify.bind(notes_dir),
        notes_dir.cachedRead.bind(notes_dir)
      );
    } else {
      await write_without_template(
        parsed_contents,
        out_file,
        notes_dir.modify.bind(notes_dir),
        preamble_file
      );
    }
    new import_obsidian4.Notice(
      partial_message + "To the vault folder inside the vault:\n" + output_folder_path + "/"
    );
  }
  async export_with_selection(active_file, selection, settings) {
    try {
      return export_selection(
        this.app.vault.cachedRead.bind(this.app.vault),
        this.find_file,
        active_file,
        selection,
        settings
      );
    } catch (e) {
      console.error(e);
    }
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "export-paper",
      name: "Export current note in-vault",
      checkCallback: (checking) => {
        const active_file = this.app.workspace.getActiveFile();
        if (!(active_file instanceof import_obsidian4.TFile)) {
          return false;
        } else if (checking) {
          return true;
        } else {
          this.find_files_and_export(active_file, this.settings);
        }
      }
    });
    this.addCommand({
      id: "export-paper-external",
      name: "Export current note to external folder",
      checkCallback: (checking) => {
        const active_file = this.app.workspace.getActiveFile();
        if (!(active_file instanceof import_obsidian4.TFile)) {
          return false;
        } else if (checking) {
          return true;
        } else {
          remote.dialog.showOpenDialog({
            properties: ["openDirectory"]
          }).then((result) => {
            if (result.canceled || !result.filePaths || result.filePaths.length === 0) {
              new import_obsidian4.Notice("External export cancelled");
              return;
            }
            const selectedPath = result.filePaths[0];
            this.export_to_external_folder(
              active_file,
              selectedPath
            );
          }).catch((err) => {
            console.error("Error opening folder picker:", err);
            new import_obsidian4.Notice("Failed to open folder picker");
          });
        }
      }
    });
    this.addCommand({
      id: "selection-export-paper",
      name: "Export selection to clipboard",
      editorCheckCallback: (checking, editor, ctx) => {
        if (checking) {
          return editor.somethingSelected();
        }
        const active_file = ctx.file;
        if (!active_file) {
          throw new Error("No active file found.");
        }
        const selection = editor.getSelection();
        this.export_with_selection(
          active_file,
          selection,
          this.settings
        );
      }
    });
    this.addSettingTab(new LatexExportSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var WarningModal = class extends import_obsidian4.Modal {
  constructor(app, plugin, callback, message) {
    super(app);
    this.plugin = plugin;
    this.rememberChoice = false;
    this.callback = callback;
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText(this.message);
    new import_obsidian4.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("OK").onClick(async () => {
        if (this.rememberChoice) {
          this.plugin.settings.warn_before_overwrite = false;
        }
        await this.callback();
        await this.plugin.saveSettings();
        this.close();
      })
    ).addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.close();
      })
    );
    const toggleContainer = contentEl.createDiv();
    toggleContainer.createDiv({ text: "Remember my choice:" });
    new import_obsidian4.Setting(toggleContainer).addToggle(
      (toggle) => toggle.setValue(false).onChange((value) => this.rememberChoice = value)
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var LatexExportSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setName("Template file").setDesc(
      "Relative vault path to a template file. Only set this if you would like to export with a template (you don't need to.)"
    ).addText(
      (text) => text.setPlaceholder("path/to/template_file.tex").setValue(this.plugin.settings.template_path).onChange(async (value) => {
        if (value === "") {
          value = "/";
        }
        this.plugin.settings.template_path = (0, import_obsidian4.normalizePath)(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Output folder").setDesc(
      "Vault relative path of an existing folder in your vault. Exports will be written within that folder."
    ).addText(
      (text) => text.setPlaceholder("path/to/output_folder/").setValue(this.plugin.settings.base_output_folder).onChange(async (value) => {
        const match = /^(?:\/|\/?(.*?)\/?)$/.exec(value);
        if (match) {
          if (match[1] === void 0) {
            value = "/";
          } else {
            value = match[1];
          }
        }
        this.plugin.settings.base_output_folder = (0, import_obsidian4.normalizePath)(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Math preamble file").setDesc(
      "Vault relative path to a preamble.sty file in your vault. It will be included in the export."
    ).addText(
      (text) => text.setPlaceholder("path/to/preamble_file").setValue(this.plugin.settings.preamble_file).onChange(async (value) => {
        this.plugin.settings.preamble_file = (0, import_obsidian4.normalizePath)(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Bib file").addText(
      (text) => text.setPlaceholder("path/to/bib_file").setValue(this.plugin.settings.bib_file).onChange(async (value) => {
        this.plugin.settings.bib_file = (0, import_obsidian4.normalizePath)(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Prioritize lists over equations").setDesc(
      "Whether to include display equations in lists, or stop the list and have the equation outside of the list."
    ).addToggle(
      (cb) => cb.setValue(this.plugin.settings.prioritize_lists).onChange(async (value) => {
        this.plugin.settings.prioritize_lists = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Overwrite preamble.sty").setDesc(
      "Overwrite the preamble file also if a preamble file is found in the root of the vault."
    ).addToggle(
      (cb) => cb.setValue(this.plugin.settings.overwrite_preamble).onChange(async (value) => {
        this.plugin.settings.overwrite_preamble = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Overwrite figure files").setDesc(
      "Overwrite figure files in the Files folder during export."
    ).addToggle(
      (cb) => cb.setValue(this.plugin.settings.overwrite_figures).onChange(async (value) => {
        this.plugin.settings.overwrite_figures = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Overwrite header file").setDesc("Overwrite the header file (header.tex) during export.").addToggle(
      (cb) => cb.setValue(this.plugin.settings.overwrite_header).onChange(async (value) => {
        this.plugin.settings.overwrite_header = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Warn before overwriting on export").addToggle(
      (cb) => cb.setValue(this.plugin.settings.warn_before_overwrite).onChange(async (value) => {
        this.plugin.settings.warn_before_overwrite = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Default cite command").addText(
      (txt) => txt.setValue(this.plugin.settings.default_citation_command).onChange(async (value) => {
        this.plugin.settings.default_citation_command = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Display environment names").setDesc(
      "Set display attribute of the wikilink as the visible name of the environment in latex. If no display value is found, the value of the yaml entry 'env_title' will be used. If that is not found, use the file name if 'Default environment title to file names' is set. Setting any such field to an empty string specifies the absence of a title."
    ).addToggle(
      (cb) => cb.setValue(this.plugin.settings.display_env_titles).onChange(async (value) => {
        this.plugin.settings.display_env_titles = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Default environment title to file name").setDesc(
      "Use file names (without the file extension) as a default environment name."
    ).addToggle(
      (cb) => cb.setValue(
        this.plugin.settings.default_env_name_to_file_name
      ).onChange(async (value) => {
        this.plugin.settings.default_env_name_to_file_name = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Last external folder").setDesc(
      "The last used external folder for exports. Updated automatically when exporting externally."
    ).addText(
      (text) => text.setPlaceholder(
        "Last used external folder (e.g., /home/user/latex)"
      ).setValue(this.plugin.settings.last_external_folder).onChange(async (value) => {
        this.plugin.settings.last_external_folder = (0, import_obsidian4.normalizePath)(value);
        await this.plugin.saveSettings();
      })
    );
  }
};

/* nosourcemap */